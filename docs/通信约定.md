电脑上位机和下位机之间的通讯数据格式
0.	更新历史记录
V1.0 first version
V1.1 添加灯的状态需求，放到VAL中每个2bytes中的最高bit表示；update in 3.5
1.	设计背景
上位机APP需要控制WS2812灯带上特定灯的亮灭，灯带是连接在下位机上，所以上位机需要发送指令给下位机，来达到控制灯带的目的；
该文档的目的是为了定义下位机和上位机之间的通讯方式以及数据格式；
2.	通讯协议
下位机和电脑通过USB数据线连接，使用UART串口通讯协议，波特率为115200，小端格式来传输数据，使用16进制数据传输；
在没有特殊说明的情况下，该文档中的数据都为16进制数；
3.	数据格式
HEADER(4)	TYPE(1)	LEN(2)	SEQ(2)	VAL(N*2)	CHECK(1)
3.1 HEADER
长度为4bytes，其值固定为F2F8F1F2，作用为作为标记说明对端发出的数据是发送给自己的；当收到数据时，只有前4bytes的值为该固定值时，才认为是有效数据包；
单片机的还会输出其他必要的log打印到串口上，这些数据也会被上位机收到，所以上位机只有在收到该固定的HEADER时，才算是发给自己的数据，才需要做进一步处理；
同时上位机发送给单片机的数据包，也要包含如上固定的HEADER；
3.2 TYPE
长度为1byte，定义几种包的类型，作用是收到消息后根据包的类型做相应的动作；
3.2.1上位机发送给下位机的TYPE定义如：
A0	A1	AF
空包	指令包	应答包
3.2.2下位机发送给上位机的TYPE定义如：
B0	B1	BF
空包	请求包	应答包
空包：上位机和下位机都会发出，作用是检查对端是否由在线；
请求包：由下位机发出，作用是向上位机请求开灯指令包，上位机收到该包之后，还需要先回复一个应答包，然后再回复一个指令包；
指令包：由上位机发出，包含需要打开灯带上的灯的序号，灯的序号从1开始，不需要分组，所有需要打开的灯的序号都放到一个数据包中发出；下位机收到后需要还需要回复一个应答包；
应答包：当收到对端发来的一个包时，则需要回复应答包给对端，表示有收到消息，并且说明处理结果；
3.3 LEN
长度为2bytes，表示SEQ、VAL、CHECK三个字段的长度之和
3.4 SEQ
长度为2bytes，表示请求包和指令包的序列号；对空包不起作用，空包的该SEQ位设置位FFFF;应答包的SEQ字段为需要应答的消息的SEQ字段；
发送的第一个包的SEQ为0，之后每发送一个包，SEQ都需要加1；接收端收到后，需要先保存SEQ，下次再收到包时，检查和上一次保存的值相比较，如果相等的话，认为是重复包，重复发送对应的应答包即可；如果大1的话，则认为是一个新包，正常处理；如果是第一个0的话，认为是第一个包，也是正常处理；否则认为是一个错误的包，丢弃该包，并回复应答包告知原因；
3.5 VAL
对于指令包，包含需要打开灯带上灯的序号和灯的状态，共2个bytes；灯的状态只有两种情况（常亮和闪烁），占用2bytes数据中的最高bit，为0表示常亮，为1表示闪烁；序号占用2bytes中的低15bits；如果需要开N个灯，则其长度就是2N bytes；
示例（小端）：index=316 常亮 → 0x013C（VAL: 3C 01）；闪烁 → 0x813C（VAL: 3C 81）。
对于应答包，其长度为1bytes，其值表示收到的包的处理结果；
对于空包和请求包，不包含该字段；
3.6 CHECK
长度为1byte，除了HEADER和自己之外的所有数据，每byte相加得到的结果，取低1byte的值作为CHECK的值，作用是防止数据在传输的过程中出现错误；接收端收到数据包后按照如上方法先自行计算CHECK的值，然后和收到的CHECK字段做比较，相等的话，正常往下处理，否则回复空包，并填入错误原因；
4.	数据包示例
4.1 空包
空包没有VAL字段
4.1.1上位机发出的空包
F2F8F1F2A00300FFFFA1
4.1.2 下位机发出的空包
F2F8F1F2B00300FFFFB1
4.2 应答包
其作用是告诉对端，其发来的数据包已经处理完成，并且包含处理结果；
应答包的VAL字段为1byte，其作用是表明消息的处理结果，其定义如：
00：处理成功；01：未知TYPE字段错误；02：LEN字段错误；03：SEQ字段过小错误；04：SEQ字段过大错误；05：VAL字段错误；06：CHECK字段错误；
4.2.1 上位机发出的应答包（假定对端发来的数据包的序列号SEQ为0500，并且VAL位为00）
F2F8F1F2AF0400050000B8
4.2.2 下位机发出的应答包（假定对端发来的数据包的序列号SEQ为0708，并且VAL位为00）
F2F8F1F2BF0400070800D2
4.3 请求包
只能由下位机发出，其作用是告诉上位机，让其发送一个亮灯指令包；该包没有VAL字段；
(假定序列号SEQ为0102)
F2F8F1F2B103000102B7
4.4 指令包
只能由上位机发出，包含需要开灯的序号，告诉下位机这些灯需要点亮；
（假设包序列号为0A00，需要开的灯的序号为第789个灯，灯的序号使用十进制数）
F2F8F1F2A105000A001503C8
（假设包序列号为0405，需要开的灯的序号为第5、10、150、890、1200个灯，灯的序号使用十进制数表示）
F2F8F1F2A10D00040505000A0096007A03B0048D
5.	数据包交互说明
5.1 空包的交互
上位机和下位机都需要每隔一定的时间发送空包给对端，对端收到后需要回复应答包，收到应答包时说明对端有在线；发送空包的间隔暂定为10秒，如果连续发送10次，都没有收到应答包，则认为对端不在线，需要上报错误给人工介入排查问题；
下图为上位机发送空包的示例，下位机发送空包也是一样的流程；
 
5.2 请求包和指令包的交互示例

附录：业务流水（非协议说明）
- 入库阶段在移动之前进行完整合法性预检：文件名正则 + 文本内容解析。文件名规则为 {w}-{h}-{order}[-{label}].{ext}（扩展名不区分大小写，ext∈{txt,jpg,jpeg}）；文本解析至少得到 1 个合法 index（范围 1..0x7FFF），percent 在 [0,100]，非法行忽略。
- 预检失败时，成对文件（.txt + .jpg/.jpeg）统一移入 error；成功时采用 .part + .pairlock 两阶段提交至 work，最终原子重命名产出稳定对。
- 分组与扫描逻辑需忽略中间态（.part 文件与存在 .pairlock 的 stem），仅消费最终态文件。
- A1 指令载荷固定为 2B/项，MSB=闪灯，低 15bit 为索引。派发时 pair 模式直接使用 indices（2B/项），不再构造 attrs。
 

